---
_id: 3b94c850-4c03-11e9-bc0f-b106493c99f0
title: TCache Exploitation in Libc 2.29 - Auxy's Blog
link: 'https://www.auxy.xyz/research/2018/11/22/TCache-Exp.html'
excerpt: talk about tcache 2.29
category: pwn
header:
  overlay_image: ''
date: '2019-03-21T18:00:38.164Z'
---
<p>
 <img src="https://www.auxy.xyz/assets/pic/tcache.jpg"/>
</p>
Preface
<p>
 Sad news for all pwners: a
 <a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d">
  new security check for TCache
 </a>
 is added recently. Emmmm, we already have over 10 exploit methods of the heap in Shellphish’s
 <a href="https://github.com/shellphish/how2heap">
  how2heap
 </a>
 . With the additional check, heap challenge will continue being a nightmare of pwners.
</p>
<p>
 The new version(2.29) is not released yet, so it probably will be changed before release date. However, I still want to discuss some probable exploit methods against the future TChache.
</p>
Changed Code
<p>
 Let’s see the diff:
</p>
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -2967,6 +2967,8 @@ mremap_chunk (mchunkptr p, size_t new_size)
 typedef struct tcache_entry
 {
 struct tcache_entry *next;
+ /* This field exists to detect double frees. */
+ struct tcache_perthread_struct *key;
 } tcache_entry;
 
 /* There is one of these for each thread, which contains the
@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx)
 {
 tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
 assert (tc_idx &lt; TCACHE_MAX_BINS);
+
+ /* Mark this chunk as "in the tcache" so the test in _int_free will
+  detect a double free. */
+ e-&gt;key = tcache;
+
 e-&gt;next = tcache-&gt;entries[tc_idx];
 tcache-&gt;entries[tc_idx] = e;
 ++(tcache-&gt;counts[tc_idx]);
@@ -3005,6 +3012,7 @@ tcache_get (size_t tc_idx)
 assert (tcache-&gt;entries[tc_idx] &gt; 0);
 tcache-&gt;entries[tc_idx] = e-&gt;next;
 --(tcache-&gt;counts[tc_idx]);
+ e-&gt;key = NULL;
 return (void *) e;
 }
 
@@ -4218,6 +4226,26 @@ _int_free (mstate av, mchunkptr p, int have_lock)
 {
  size_t tc_idx = csize2tidx (size);
 
+ /* Check to see if it's already in the tcache. */
+ tcache_entry *e = (tcache_entry *) chunk2mem (p);
+
+ /* This test succeeds on double free. However, we don't 100%
+  trust it (it also matches random payload data at a 1 in
+  2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence
+  before aborting. */
+ if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))
+  {
+  tcache_entry *tmp;
+  LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
+  for (tmp = tcache-&gt;entries[tc_idx];
+   tmp;
+   tmp = tmp-&gt;next)
+   if (tmp == e)
+   malloc_printerr ("free(): double free detected in tcache 2");
+  /* If we get here, it was a coincidence. We've wasted a few
+   cycles, but don't abort. */
+  }
+
  if (tcache
  &amp;&amp; tc_idx &lt; mp_.tcache_bins
  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)
<p>
 And here is the new protect mechanism:
</p>
typedef struct tcache_entry
 {
 struct tcache_entry *next;
 /* This field exists to detect double frees. */
 struct tcache_perthread_struct *key;
 } tcache_entry;
 
// tcache_put
{
...
 tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
 assert (tc_idx &lt; TCACHE_MAX_BINS);
 /* Mark this chunk as "in the tcache" so the test in _int_free will detect a double free.*/
 e-&gt;key = tcache;
 tcache-&gt;entries[tc_idx] = e;
 ++(tcache-&gt;counts[tc_idx]);
...
}
// tcache_get
{
...
 assert (tcache-&gt;entries[tc_idx] &gt; 0);
 tcache-&gt;entries[tc_idx] = e-&gt;next;
 --(tcache-&gt;counts[tc_idx]);
 e-&gt;key = NULL;
 return (void *) e;
...
}
// _int_free
{
...
 /* Check to see if it's already in the tcache. */
 tcache_entry *e = (tcache_entry *) chunk2mem (p);
 
 /* This test succeeds on double free. However, we don't 100%
 trust it (it also matches random payload data at a 1 in
 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence*/
 if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))
 {
 tcache_entry *tmp;
 LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
 for (tmp = tcache-&gt;entries[tc_idx];
  tmp;
  tmp = tmp-&gt;next)
 if (tmp == e)
  malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence. We've wasted a few
 cycles, but don't abort. */
 }
...
}
<p>
 The code is easy to understand. It adds following mitigation:
</p>
When user free a chunk to TCache, it
 
  Check whether the chunk contains valid key(it acts like stack canary), if it does, libc:
  
   Checks if the address is duplicated in tcache-&gt;entries array by looping
   When it’s not duplicated, return malloc. Otherwise aborting the program.
  
  
  Use pointer tcahce(which stores the tcache_perthread_struct) info as key for further security check
 
 
 When user malloc from TCache, it
 
  erase the key content to prevent leaking
<p>
 To summarize, we cannot add any chunks twice in TCache without modifying key, no matter subsequently or intermittently. (even the something like fastbin double free A-&gt;B-&gt;A)
</p>
New Techniques Against Mitigation
<p>
 These are only proposed, they might be changed before glibc 2.29 released to date.
</p>
Overwrite the key (Bypass)
<p>
 This is the most obvious option, we can achieve it via overlapping chunks or unsorted bins attack. Any methods that can overwrite the key will be a great help.
</p>
TCache + Fastbin Double Free (Arbitrary R/W)
<p>
 Now, we cannot free a chunk to cache directly. However, we can fill 6 chunks to a TCache list(while the max of a list is 7). Then free Chunk A to TCache.
</p>
<p>
 The TCache is now full filled, and the program will use Fastbin instead. Since the fastbin won’t check key, we can double free Chunk A to fastbin.
</p>
<p>
 In the final, we can overwrite bk to malloc an arbitrary chunk.
</p>
TCache + Unsorted Bin Double Free (Leak Heap)
<p>
 The process is similar to the above steps. Fill 6 chunks to TCache list.
</p>
<p>
 Subsequently, put a chunk in size of small bin to TCache and unsorted bin.
</p>
<p>
 After malloc our chunk. We can see bk address of unsorted bin (leaking Heap). The fk pointer will be erased because of e-&gt;key = NULL; in tcache_get. We need to recover it to a correct address or give up using unsorted bin.
</p>
Leaking the address of tcache (Leak glibc)
<p>
 According to libc, this is the definition of tcache:
</p>
static __thread tcache_perthread_struct *tcache = NULL;
<p>
 Since it’s created statically, its relative address is always constant, we have another leak choice.
</p>
<p>
 Remember, when we free a chunk from TCache, its key will be erased. So we can only leak the chunks already in TCache.
</p>
Conclusion
<p>
 Remember, this is not released yet and might be changed. But I still hope the whole passage will be useful in future attack. If you spark some great ideas or want to correct my article, don’t forget to comment in the bottom.
</p>
