---
_id: b83930c0-2cfb-11e9-b328-cb733bb1f111
title: Attacking RSA for fun and CTF points ‚Äì part 1
link: 'https://bitsdeep.com/posts/attacking-rsa-for-fun-and-ctf-points-part-1/'
excerpt: >-
  [latexpage] Introduction RSA is my favorite cryptosystem. :) It‚Äôs simple and
  powerful. In this series I will try to go through every attacks (that I‚Äôm
  aware of) against RSA which are us‚Ä¶
category: crypto
header:
  overlay_image: 'https://bitsdeep.com/wp-content/uploads/2018/03/22tuhy.jpg'
date: '2019-02-10T06:18:45.236Z'
---
Introduction
<p>
 RSA is my favorite cryptosystem. üôÇ It‚Äôs simple and powerful.
</p>
<p>
 In this series I will try to go through every attacks (that I‚Äôm aware of) against RSA which are useful for solving CTF tasks. 
I‚Äôm not going to give you scripts that will do all the work for you but rather explain how the attacks work. The aim of this series is to understand the attacks you use and which one is most appropriate depending on the task. I will try to be beginner friendly and repeat myself in the beginning but afterwards I will assume that the reader has learnt the concepts.
</p>
<p>
 Before entering into the details on how to break RSA based challenges, let‚Äôs see how textbook RSA works. I‚Äôm not talking about RSA used with padding as it is in real world cryptography.
</p>
How simple maths can keep your data private 
 RSA is based on simple modular arithmetics. It doesn‚Äôt require a lot of maths knowledge to understand how it works. As it‚Äôs an asymmetric cipher, you have two keys, a public key containing the couple (
<p>
 <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-3767ff142072a7200ab99e8a6b98520b_l3.png"/>
</p>
,
<p>
 <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-51527def57feb35469875bec04e4ad4c_l3.png"/>
</p>
) and a private key containing a bunch of information but mainly the couple (
<p>
 <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-3767ff142072a7200ab99e8a6b98520b_l3.png"/>
</p>
,
<p>
 <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-cb801b464df990e988e5b2e2b293d669_l3.png"/>
</p>
).
<p>
 Here comes the most important part, this must be fully understood in order to understand the attacks that will be described. 
The modulus
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-3767ff142072a7200ab99e8a6b98520b_l3.png"/>
 </p>
 is chosen from two primes:
</p>
<p>
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-72c80ad3dacb40a8e017258093470bd7_l3.png"/>
 </p>
 with
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-ea925e2dc8750c7f13c22ba2d84bd7fc_l3.png"/>
 </p>
 and
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-d4ad2a64838272862dab571ac7d507a6_l3.png"/>
 </p>
 being prime integers (chosen carefully)
</p>
<p>
 To choose a valid public exponent
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-51527def57feb35469875bec04e4ad4c_l3.png"/>
 </p>
 you first need to compute
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-c5e65465d89e11700dca1654d9a840d0_l3.png"/>
 </p>
 , also called Euler‚Äôs totient function.
</p>
<p>
 Note : Now, in real world RSA, you don‚Äôt use Euler‚Äôs totient function but rather
 <a href="https://en.wikipedia.org/wiki/Carmichael%27s_totient_function">
  Carmichael‚Äôs totient function
 </a>
 .
</p>
<p>
 Then
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-51527def57feb35469875bec04e4ad4c_l3.png"/>
 </p>
 must verify those 2 conditions:
</p>
<p>
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-670e9d7675d8ff79961d8aa6af4e9b96_l3.png"/>
 </p>
 and
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-140ad7fe4232f102247dcb359b0e5d0f_l3.png"/>
 </p>
 , that means that
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-51527def57feb35469875bec04e4ad4c_l3.png"/>
 </p>
 and
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-fb0161903dfdc7a244919840e40b2467_l3.png"/>
 </p>
 are coprime.
</p>
<p>
 Now you have a valid public key, we just need to compute the private exponent
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-cb801b464df990e988e5b2e2b293d669_l3.png"/>
 </p>
 as the modular inverse of
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-51527def57feb35469875bec04e4ad4c_l3.png"/>
 </p>
 modulo
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-fb0161903dfdc7a244919840e40b2467_l3.png"/>
 </p>
 . In short, find a value for
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-cb801b464df990e988e5b2e2b293d669_l3.png"/>
 </p>
 such that
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-889032915ac7a2ec1fec41af7d73d6ba_l3.png"/>
 </p>
</p>
<p>
 Note : keys are encoded in PEM format but it‚Äôs not relevant for this example.
</p>
The encryption process
<p>
 Let‚Äôs say you want to encrypt this message with your public key¬†: ‚ÄúMy credit card number is 1337‚Äù.
</p>
<p>
 Public key :
</p>
n = 30994968412821274638126108542140224647370292100079091608343041083209715023181825537637957453183815788151099869840363450721
e = 65537
<p>
 You‚Äôll first need to transform it into a number. Usually it‚Äôs done like this :
</p>
&gt;&gt;&gt; "My credit card number is 1337".encode('hex')
'4d79206372656469742063617264206e756d6265722069732031333337'
&gt;&gt;&gt; m = 0x4d79206372656469742063617264206e756d6265722069732031333337
&gt;&gt;&gt; m
2088672004503895363248317162088008321096572194316716175821104101929783L
<p>
 You then compute
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-d81e5f7d40115d533b4fe467b33684c3_l3.png"/>
 </p>
 where
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-87ccaf8d05f6a14d33f962fe64cc3b5a_l3.png"/>
 </p>
 is the resulting ciphertext. Only you (who have the private key) will be able to decrypt it. At least in theory because that‚Äôs what this series is all about, attacking RSA üôÇ
</p>
&gt;&gt;&gt; c = pow(m,e,n)
&gt;&gt;&gt; c
3740808283126743789473658216888004237756151970385422112230702175214670415045578511813428786937523016996521109011952458274L
 The decryption process
<p>
 To decrypt a ciphertext you need to know the private key corresponding to the public key used to encrypt it. Private key :
</p>
n = 30994968412821274638126108542140224647370292100079091608343041083209715023181825537637957453183815788151099869840363450721
d = 10949944362147351445695313961215384000802056441294706923101734114824865877971959648683318864984560110549528540371119079473
<p>
 Once you have everything, you do the same operation as for the encryption except you use
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-cb801b464df990e988e5b2e2b293d669_l3.png"/>
 </p>
 as the exponent instead of
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-51527def57feb35469875bec04e4ad4c_l3.png"/>
 </p>
 :
</p>
<p>
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-ba3e7ff6aab4de699d398ac2e84303f5_l3.png"/>
 </p>
 where
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-5a0ec4c25a63fc20a13ee9337327a5cb_l3.png"/>
 </p>
 is the resulting plaintext.
</p>
&gt;&gt;&gt; t = pow(c,d,n)
&gt;&gt;&gt; t
2088672004503895363248317162088008321096572194316716175821104101929783L
&gt;&gt;&gt; hex(t)
'0x4d79206372656469742063617264206e756d6265722069732031333337L'
&gt;&gt;&gt; "4d79206372656469742063617264206e756d6265722069732031333337".decode('hex')
'My credit card number is 1337'
 Key structure
<p>
 I told you at the beginning that key are encoded in PEM format. Here is what they really look like :
</p>
-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIw/U51Fghh6WumZQjg9l3a6AjFZ+xm2
x2+9ja+8n8Yg95Hbxsp9vCpwlIol1A5wMo6p/hNlxzAE3/cY08eKzDMCAwEAAQ==
-----END PUBLIC KEY-----
-----BEGIN RSA PRIVATE KEY-----
MIIBOQIBAAJBAIw/U51Fghh6WumZQjg9l3a6AjFZ+xm2x2+9ja+8n8Yg95Hbxsp9
vCpwlIol1A5wMo6p/hNlxzAE3/cY08eKzDMCAwEAAQJAJearQxJYwSK31O9dDPPg
Le7AzvOBP4a8yP7R/o8cIp+3XdCXzuUreFzTWTXIg76tohg8cQb77HT/jVo2rLXa
AQIhAOrtFkJ0So2NZIp4xBPLqFozaSJNti8Yx8w1IOWoS2szAiEAmNQCPrBaB6p4
heIDYgaTYpJa4gbw3tLe82AAKzFLGwECIE/ZA37Uzd4s16ZlA6gCyZbW8H3zUd/S
GV6kFClauT+XAiBZuddbkNQ6vfYmvIw56Bxt+flLzMFsQSfOgaV3tmgfAQIgKW7C
LI1+rBn3TvmyLMZ7+3TEtVeTVRgabLWyOUjmv7w=
-----END RSA PRIVATE KEY-----
<p>
 I‚Äôm not going to detail the format used. PEM is just ASN.1 data put between headers. ASN.1 is a formatted binary representation of data and it uses base64 for the final encoding.
</p>
<p>
 You can use an
 <a href="https://lapo.it/asn1js/">
  online decoder
 </a>
 , openssl or python to extract the data from the keys.
</p>
from Crypto.PublicKey import RSA
f = open('public.pem','r')
key = RSA.importKey(f.read())
print(key.n)
print(key.e)
<p>
 Let‚Äôs verify that the public key only contains
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-3767ff142072a7200ab99e8a6b98520b_l3.png"/>
 </p>
 and
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-51527def57feb35469875bec04e4ad4c_l3.png"/>
 </p>
 .
</p>
<p>
 <p>
  <img src="https://bitsdeep.com/wp-content/uploads/2018/03/Capture.png"/>
 </p>
</p>
<p>
 This above is the ASN.1 structure of the public key. There is some metadata indicating the encryption type and at the end there are two integers: the 512 bit
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-3767ff142072a7200ab99e8a6b98520b_l3.png"/>
 </p>
 and the classic
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-51527def57feb35469875bec04e4ad4c_l3.png"/>
 </p>
 .
</p>
<p>
 I told you that a private key contains more than just
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-cb801b464df990e988e5b2e2b293d669_l3.png"/>
 </p>
 and
 <p>
  <img src="https://bitsdeep.com/wp-content/ql-cache/quicklatex.com-3767ff142072a7200ab99e8a6b98520b_l3.png"/>
 </p>
 . This is the ASN.1 syntax for
 <a href="https://tools.ietf.org/html/rfc3447#appendix-A.1">
  PKCS1
 </a>
</p>
<blockquote>
 <p>
  Version ::= INTEGER { two-prime(0), multi(1) } 
(CONSTRAINED BY 
{‚Äì version must be multi if otherPrimeInfos present ‚Äì})
 </p>
 <p>
  RSAPrivateKey ::= SEQUENCE { 
version Version, 
modulus INTEGER, ‚Äî n 
publicExponent INTEGER, ‚Äî e 
privateExponent INTEGER, ‚Äî d 
prime1 INTEGER, ‚Äî p 
prime2 INTEGER, ‚Äî q 
exponent1 INTEGER, ‚Äî d mod (p-1) 
exponent2  ...
